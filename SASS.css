/* Almacenar datos con variables SASS*/

$main-fonts: Arial, sans-serif;
$headings-color: green;

/* Para usar variables SASS*/

h1 {
    font-family: $main-fonts;
    color: $headings-color;
}

/*Anidar CSS con SASS*/
/*Normalmente con CSS se pone un una linea diferente el estilo para cada elemento*/

nav {
    background-color: red;
  }
  
  nav ul {
    list-style: none;
  }
  
  nav ul li {
    display: inline-block;
  }

/*pero con SAAS, es posible organizar de forma anidada los estilos de los elementos hijos bajo su padre*/

nav {
    background-color: red;
  
    ul {
      list-style: none;
  
      li {
        display: inline-block;
      }
    }
}

/*Crear CSS reutilizable con SASS a través de MIXINS*/
/* Un MIXIN es como una función de JS. Permite agrupar reglas CSS para ser reutilizadas sin  necesidad de volver a escribirlas*/

@mixin box-shadow($x, $y, $blur, $c){ 
    -webkit-box-shadow: $x $y $blur $c;
    -moz-box-shadow: $x $y $blur $c;
    -ms-box-shadow: $x $y $blur $c;
    box-shadow: $x $y $blur $c;
}

/* La definición empieza con @mixin seguido de un nombre personalizado. Los parámetros ( $x, $y, $blur, y $c en el ejemplo anterior) son opcionales. Ahora cada vez que se necesite una regla box-shadow, una sola línea llamando al mixin reemplaza el tener que escribir todos los prefijos del proveedor. Se llama a un mixin con la directiva @include:*/

div {
    @include box-shadow(0px, 0px, 4px, #fff);
}

/*Otro ejemplo*/

@mixin border-radius($radius){
    -webkit-border-radius: $radius;
    -moz-border-radius: $radius;
    -ms-border-radius:$radius;
    border-radius:$radius;
}

#awesome {
    width: 150px;
    height: 150px;
    background-color: green;
    @include border-radius(15px); /*Llamo el mixin*/
}

/*Con SASS se puede utilizar @if y @else para aplicar lógica mis estilos css junto con el uso de MIXINS*/

@mixin border-stroke($val){ /* Creando un MIXIN llamado border-stroke que recibe un argumento $val*/
    @if $val == light{
      border: 1px solid black;
    }@else if $val == medium{
      border: 3px solid black;
    }@else if $val == heavy{
      border: 6px solid black;
    }@else{
      border:none;
    }
}

#box { /*Llamando el MIXIN  border-stroke pasandole un argumento $val que se evalua en las condiciones lógicas*/
        width: 150px;
        height: 150px;
        background-color: red;
        @include border-stroke(medium);
}

/* Usando @for para un loop de SASS*/
/* IMPORTANTE: "start to end" excluye el último numero de la secuencia. "start through end" incluye el último número de la secuencia de conteo del for.*/

@for $i from 1 through 12 { /* desde el principio "hasta" el fin, es decir, incluye el último número de la secuencia a contar*/
    .col-#{$i} { width: 100%/12 * $i; }
}

/*La parte #{$i} es la sintaxis para combinar una variable (i) con texto para hacer una cadena. Cuando el archivo Sass se convierte en CSS, tiene este aspecto:*/

.col-1 {
    width: 8.33333%;
  }
  
  .col-2 {
    width: 16.66667%;
  }
  
  ...
  
  .col-12 {
    width: 100%;
}
/*Esta es una manera poderosa de crear un diseño de cuadrícula (grid). Ahora tienes doce opciones de ancho de columna disponibles como clases CSS.*/

/*Otro ejemplo de utilización de @for para crear distintas clases de texto. En este caso uso "from to"*/
@for $j from 1 to 6{
    .text-#{$j}{ font-size:15px*$j}
}

/*Usar @each para asignar elementos en una lista o mapa. Al igual que @for, @each hace un bucle sobre cada elemento de una lista o mapa. En cada iteración, la variable se asigna al valor actual de la lista o del mapa.*/

@each $color in blue, red, green {
    .#{$color}-text {color: $color;}
}
/*En caso de mapa*/
$colors: (color1: blue, color2: red, color3: green);

@each $key, $color in $colors {
  .#{$color}-text {color: $color;}
}

/*Aplica un estilo hasta que se cumpla una condición con @while*/
/*En el ejemplo se crear 5 clases diferentes de texto con un font size distinto*/
$x:1;
@while $x <=5{
  .text-#{$x}{font-size:15px*$x;}
  $x: $x + 1;
}